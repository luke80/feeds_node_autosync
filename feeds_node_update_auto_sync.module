<?php

/**
 * Implements hook_help().
 *
 * Displays help and module information.
 *
 * @param path
 *   Which path of the site we're using to display help
 * @param arg
 *   Array that holds the current path as returned from arg() function
 */
function feeds_node_update_auto_sync_help($path, $arg) {
	switch ($path) {
		case "admin/help#feeds_node_update_auto_sync":
			return '<p>' . t("Connect nodes to their defined feed URL for automatic updates!") . '</p>';
			break;
	}
}

/**
 * Implements hook_node_update().
 */
function feeds_node_update_auto_sync_node_update( $node ) {
	
	$result = db_select('feeds_item', 'n')
		->fields('n', array('id', 'url', 'entity_id', 'imported'))
		->condition('entity_id', $node->nid) //Published.
		->condition('entity_type', 'node')
		->execute();
	
	$row = $result->fetchAssoc();
	
	if( $row['imported'] < (REQUEST_TIME - 30) ) {
		$feed_source = feeds_source($row['id']);
	
		$feed_config = $feed_source->getConfigFor($feed_source->importer->fetcher);
		$feed_config['source'] = $row['url'];
		dpm($feed_config);
		
		$feed_source->setConfigFor($feed_source->importer->fetcher, $feed_config);
		$feed_source->startImport();
	}
}

/**
 * Implements hook_form_alter().
 */
function feeds_node_update_auto_sync_form_node_type_form_alter( &$form, &$form_state, $form_id ) {
	$content_module_type = $form['#node_type']->module;
	$config_problems = array();
	$form_importers = array();
	if($content_module_type != "node") {
		$config_problems[] = t("Sorry, the type needs to be 'node', not ".$content_module_type);
	}
	$form['feeds_auto_sync'] = array(
	 '#type' => 'fieldset',
	 '#title' => t('Feeds Auto-Sync'),
	 '#collapsible' => TRUE,
	 '#collapsed' => TRUE,
	 '#group' => 'additional_settings',
	);
	//	The importer needs to be configured for the node type loaded...
	$content_node_type = $form['#node_type']->type;
	$available_importers = array();
	foreach (feeds_importer_load_all() as $importer) {
		//	Skip importers that are defined in code and are provided by the current
		//	module. This ensures that modules that define both an importer and a
		//	plugin can still be disabled.
		if ($importer->export_type == EXPORT_IN_CODE) {
			$configs = ctools_export_load_object('feeds_importer', 'names', array($importer->id));
			if (isset($configs[$importer->id]) && $configs[$importer->id]->export_module === $file->name) {
				continue;
			}
		}
		$importer_config = $importer->getConfig();
		//	Check and enforce that the node type (bundle) matches the current, and that the feed is set to 'update existing nodes'
		if($importer_config['content_type'] == $content_node_type && $importer_config['processor']['config']['update_existing'] == 2) {
			$available_importers[$importer_config['description']] = array("importer"=>$importer, "config"=>$importer_config);
		}
	}
	if(count($available_importers) == 0) {
		$config_problems[] =	t('You don\'t even have an importer set up yet! Sorry, but you\'ll have to set one up with this content type (\''.$content_node_type.'\') first.');
	}
	foreach($available_importers as $available_importer) {
			$feeds_source_mapped = false;
			foreach($available_importer['config']['processor']['config']['mappings'] as $map) {
				if($map['target'] == "feeds_source") {
					$feeds_source_mapped = true;
					break 1;
				}
			}
			$available_importer['feeds_source_mapped'] = $feeds_source_mapped;
			if($feeds_source_mapped) {
				$form_importers[t($available_importer['config']['name'])] = t($available_importer['config']['description']);
			}
	}
	if(count($form_importers) == 0) {
		if(count($available_importers) !== 0)
			$config_problems[] =	t('Your configured feed needs to have a \'feed_source\' set. You do this by setting one of the import fields mapped to \'feed_source\'. It also helps to make the data provided function as a sync source for the specific node it creates/updates.');
		else
			$config_problems[] =	t('It appears that your importers are either missing or are not set up to be compatible with an auto-update. You must map a feed_source to the feed source (called a \'feed_source\' in the mappings), which should be a unique feed_source to update only that node.');
	}

	//	Verify successful import of nodes
	$nids = db_select('node', 'n')
		->fields('n', array('nid'))
		->fields('n', array('type'))
		->condition('n.type', $content_node_type)
		->execute()
		->fetchCol(); // returns an indexed array
	$result = db_select('feeds_source', 'fs')
		->fields('fs', array('id'))
		->fields('fs',array('source'))
		->condition('fs.feed_nid', $nids)
		->condition('fs.source', "", $operator = '<>')
		->execute();
	if($result->rowCount() == 0) {
		$config_problems[] =	t('Before setting auto-update on a content type, you need to successfully sync your nodes manually at least once. (No \'feed_source\' data found.)<br/><a href="/import/'.array_keys($form_importers)[0].'"></a>'); 
	}
	//
	//	Section for modifications to the form
	//
	if(count($config_problems) == 0) {
		//	$form['feeds_auto_sync']['#title'] = t('Auto-sync ready!');
		$form['feeds_auto_sync']['importer']  = array(
		'#type' => 'select',
		'#options' => drupal_map_assoc($form_importers),
		'#title' => t('Which importer do you want the auto-sync to use?'),
		'#description' => t('Overridden settings include; deactivate missing items...'),
		);
	/*
	 * Todo:
	 * specify "deactivation" of node edit form elements
	 * connect these settings to sync code
	 * create importer overrides and complete the description on the previous (line 120)
	 * 
	 */
	} else {
		$form['feeds_auto_sync']['importer']  = array(
				'#markup' => t(implode("<br/>",$config_problems)),
		);
	}
}
