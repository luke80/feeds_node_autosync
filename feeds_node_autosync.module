<?php

/**
 * Implements hook_help().
 *
 * Displays help and module information.
 *
 * @param path
 *   Which path of the site we're using to display help
 * @param arg
 *   Array that holds the current path as returned from arg() function
*/
function feeds_node_autosync_help($path, $arg) {
	switch ($path) {
		case "admin/help#feeds_node_autosync":
			return '<p>' . t("Connect nodes to their defined feed URL for automatic updates!") . '</p>';
			break;
	}
}

/**
 * Implements hook_schema_alter().
 *
 * Modifies the 'node_type' schema, adding a toggle and config column
 *
 * @param schema
 *   Entire schema, used to modify data the structure
*/
function feeds_node_autosync_schema_alter(&$schema) {
	$schema['node_type']['fields']['auto_sync_toggle'] = array(
			'type' => 'int',
			'not null' => TRUE,
			'default' => 0,
			'description' => 'Toggle setting for auto-sync (feeds) module.',
	);
	$schema['node_type']['fields']['auto_sync_config'] = array(
		'type' => 'blob',
		'size' => 'big',
		'not null' => FALSE,
		'serialize' => TRUE,
		'description' => 'Configuration for auto-sync (feeds) module.',
	);
}

/**
 * Implements hook_enable().
 *
 * !Mostly for development purposes... remove for release
 * Ensures that installation script is re-run with disable, re-enable 
 *
 */
function feeds_node_autosync_enable() {
	feeds_node_autosync_install();
}

/**
 * Implements hook_node_update().
 *
 * Main engine of the autosync. Adds the automatic import request to node update events via the hook.
 *
 * @param node
 *   Contains the node which was updates (the update that fired the hook)
*/
function feeds_node_autosync_node_update( $node ) {
	$c = feeds_node_autosync_config($node->type);		//	Load the configuration settings for this node type!
	//	watchdog('feeds_node_autosync',"hook node_update fired!",NULL,WATCHDOG_DEBUG);	//	Perhaps we should log this kind of thing?
	if($c->config->active->value == 1) {	//	If this node type is set to actively auto-sync...
		//	Retrieve the feeds_item
		$feeds_items_result = db_select('feeds_item', 'n')
			->fields('n', array('id', 'url', 'entity_id', 'imported'))
			->condition('entity_id', $node->nid)
			->condition('entity_type', 'node')	//	Conditions deliberately not matching against feed_importer_id (expecting there to be a 1st one that imports all and a 2nd one that is used to auto-sync)
			->orderby('imported','DESC')		//	Newest (most recent) first
			->range(0,1)		//	But only give me the one...
			->execute();
		$feeds_items_row = $feeds_items_result->fetchAssoc();
		//	If the request time minus the import timestamp (age in seconds since last request) is greater than the tolernace setting, perform an import!
		if( (REQUEST_TIME - $feeds_items_row['imported']) > $c->config->cooldown->value ) {
			$feed_source = feeds_source($c->config->importer->value);
			$feed_config = $feed_source->getConfig();
			$feed_config['FeedsHTTPFetcher']['source'] = $feeds_items_row['url'];
			$feed_source->setConfig($feed_config);
			//	Optional message to alter the user that the update has begun?
			//	drupal_set_message(t('Updating %node_title from feed source.',array('%node_title'=>$node->title)),'status',TRUE);
			$feed_source->startImport();
			//	I saw somewhere that this would perform the batch without the ajax thing... but I found it worked less reliably.
			//	while (FEEDS_BATCH_COMPLETE != $feed_source->import());
		} else {
			//	Since updating the node fires this update hook, a second event is inevitable. This event verifies that the node has been updated indeed, therefore show the updated from source message.
			drupal_set_message(t('%node_title updated from feed source.',array('%node_title'=>$node->title)),'status',TRUE);
		}
	}
}

/**
 * Implements hook_form_alter().
 *
 * Modifies the "node_type" form. Adds configuration options to the node type for auto-sync of content of this type.
 *
 * @param form
 *   The form array, containing the "current" state of the form.
 * @param form_state
 *   A keyed array containing the current state of the form.
 * @param form_id
 *   String representing the name of the form itself. This is the "FORM_ID" part of the name of the function.
 */
function feeds_node_autosync_form_alter( &$form, &$form_state, $form_id ) {
	if (isset($form['type']) && $form['type']['#value'] . '_node_form' == $form_id) {
		$c = feeds_node_autosync_config($form['#node']->type);
		if(array_key_exists("title",get_object_vars($c->config->block_field_edits->value)))
			$form['title']['#type'] = 'value';
		foreach(get_object_vars($c->config->block_field_edits->value) as $field_name) {
			if(array_key_exists($field_name,$form)) {
				$form[$field_name]['#disabled'] = TRUE;
				//$form[$key]['#readonly'] = 'readonly';
				$form[$field_name]['#type'] = 'value';
			}
		}
		/*
		foreach($form as $key=>$value) {
			//dpm($key);
			//dpm($value);
			if(is_array($value))
				if(array_key_exists('#title',$value)) {
					$form[$key]['#disabled'] = TRUE;
					//$form[$key]['#readonly'] = 'readonly';
					$form[$key]['#type'] = 'value';
				} else if(is_string($key)) {
					//$form[$key]['#disabled'] = TRUE;
				}
		}
		*/
		if(array_key_exists('feeds',$form) && array_key_exists('FeedsHTTPFetcher', $form['feeds'])) {
			$form['feeds']['#disabled'] = TRUE;
			foreach($form['feeds'] as $key=>$value) {
				if(preg_match("/^Feeds.+Parser\$/",$key) != 0) unset($form['feeds'][$key]);
			}
		}
	}
}

/**
 * Implements hook_FORM_ID_form_alter().
 *
 * Modifies the "node_type" form. Adds configuration options to the node type for auto-sync of content of this type.
 *
 * @param form
 *   The form array, containing the "current" state of the form.
 * @param form_state
 *   A keyed array containing the current state of the form.
 * @param form_id
 *   String representing the name of the form itself. This is the "FORM_ID" part of the name of the function.
*/
function feeds_node_autosync_form_node_type_form_alter( &$form, &$form_state, $form_id ) {
	//	Retrieve the configuration object..
	$c = feeds_node_autosync_config($form['#node_type']->type);
	
	//	Initialize the $form_datas to contain all the requisite data places
	$form_datas = array(
			'config_problems'		=> array(),		//	This array is populated with helpful text to assist the user to configure the feed to work with this module.
			'importers' => array(
				'all'	=> array(),	//	This array is populated with all the form importers found, and holds a boolean value which is true if this importer is valid for auto-syncing the nodes.	
				'valid'		=> array(),	//	This array is populated with the form importers that are valid for use.
				'fields'	=> array(),	//	This array is populated with the form fields that are mapped specifically in this importer.
			),
			'importer_mapped_fields'	=> array(),	//	This array is populated with the mapped fields that are configured, and might need to be disabled to prevent modification to fields intended to be driven only by the feed.
	);
	if($form['#node_type']->module != "node") {
		$form_datas['config_problems'][] = t("Sorry, the type needs to be 'node', not %module_name.",array('%module_name',$form['#node_type']->module));
	} else {
		//	The importer needs to be configured for the node type loaded...
		foreach(feeds_importer_load_all() as $importer) {
			$validation_data = feeds_node_autosync_validate_importer($importer->id, $form['#node_type']->type);
			$form_datas['importers']['all'] =		array_merge($form_datas['importers']['all'], $validation_data['all']);
			$form_datas['importers']['valid'] =		array_merge($form_datas['importers']['valid'], $validation_data['valid']);
			$form_datas['importers']['fields'] =	array_merge($form_datas['importers']['fields'], $validation_data['mapped_fields']);
			$form_datas['importer_mapped_fields'] =	array_merge($form_datas['importer_mapped_fields'], $validation_data['mapped_fields']);
		}
	}
	if(count($form_datas['importers']['all']) == 0) {	//	First problem to identify. No importers!
		$form_datas['config_problems'][] =	t('<p class="error">You don\'t even have an importer set up yet! Sorry, but you\'ll have to set one up with this content type %content_type first.</p>',array('%content_type'=>$form['#node_type']->type));
	} else if(count($form_datas['importers']['valid']) == 0) {	//	Second problem to identify. No valid importers!
		$form_datas['config_problems'][] =	t('<p class="error">Found %num_feeds available feeds, but none passed validation.<br/><br/>Your configured feed needs to have a <em>feed_source</em> set. You do this by setting one of the import fields mapped to <em>feed_source</em>. It also helps to make the data provided function as a sync source for the specific node it creates/updates.</p>',array('%num_feeds'=>count($form_datas['importers']['all'])));
		$form_datas['config_problems'][] = t('<h4>"Semi-valid" feed list with requirements unmet:</h4>');
		foreach($form_datas['importers']['all'] as $key=>$unvalidated_importer) {
			dpm($key);
			dpm($unvalidated_importer);
			$form_datas['config_problems'][] = t("<em>".$key."</em>");
			if(array_key_exists('fail_messages', $unvalidated_importer)) {
				foreach($unvalidated_importer['fail_messages'] as $fail_message)
					$form_datas['config_problems'][] = $fail_message;
			}
		}
	} else if(count($form_datas['importer_mapped_fields']) == 0) {	//	Third problem to identify. No fields mapped to update in this content type.
		$form_datas['config_problems'][] =	t('<p class="error">It appears that your <em>processor</em> is either missing or is not set up to connect to this content type with any imported columns. Additionally, you are also required to have at least one unique identifier mapped to this content type %content_type, and the processor set to <em>update existing nodes</em>.',array('%content_type'=>$form['#node_type']->type));
	}
	
	//	Verify successful import of nodes with 'FEED_URL' set in db.
	$missing_nodes_error = t('Before setting auto-update on a content type, you need to successfully sync your nodes manually at least once. (No \'feed_source\' data found.)');
	foreach($form_datas['importers']['valid'] as $importer_name=>$importer) {
		$missing_nodes_error .= t('%existing_errors %new_error',array('%existing_errors' => $missing_nodes_error,'%new_error'=>'<p class="error"><a href="/import/'.$importer_name.'">Click here to go import page for "'.$importer.'"</a>'));
	}
	$form_datas['nids'] = db_select('node', 'n')
		->fields('n', array('nid'))
		->fields('n', array('type'))
		->condition('n.type', $form['#node_type']->type)
		->condition('n.status', 1)
		->execute()
		->fetchCol(); // returns an indexed array
	if(count($form_datas['nids']) > 0 && count($form_datas['config_problems']) == 0) {
		$result = db_select('feeds_source', 'fs')
			->fields('fs', array('id'))
			->fields('fs',array('source'))
			->condition('fs.feed_nid', $form_datas['nids'])
			->condition('fs.source', '', $operator = '<>')
			->range(0,1)
			->execute();
		if($result->rowCount() == 0) {
			$form_datas['config_problems'][] =	$missing_nodes_error;
		}
	} else if(count($form_datas['config_problems']) == 0) {
		$form_datas['config_problems'][] =	$missing_nodes_error;
	}
	unset($form_datas['nids']);
	unset($result);
	unset($missing_nodes_error);
	
	/*
		*	Finally! Begin modifications to the form
	*/
	//	Create the new tab (appears at the bottom of the form, probably under "Comment settings"
	$form['feeds_auto_sync'] = array(
	 '#type' => 'fieldset',
	 '#title' => t('Feeds Auto-Sync'),
	 '#collapsible' => TRUE,
	 '#collapsed' => TRUE,
	 '#group' => 'additional_settings',
	);
	//	If there are errors to display, display them.
	if(count($form_datas['config_problems']) != 0) {
		$form['feeds_auto_sync']['fna_errors']  = array(
				'#markup' => t(implode("<br/>",$form_datas['config_problems'])),
		);
		//	Since the form settings don't matter if they can't work, hide them.
		return true;
	}
	//	Main control setting. Destination: `node_type`.`auto_sync_toggle`
	$form['feeds_auto_sync']['fna_active']  = array(
		'#type' => 'checkbox',
		'#title' => t('Auto-sync this content type?'),
		'#description' => t('With this checked, when items of this type are modified they will trigger a re-import from the configured source.'),
	);
	if($c->config->active->value == 1) {
		$form['feeds_auto_sync']['fna_active']['#attributes'] = array('checked'=>'checked');
	}
	//	Secondary control. Destination: ctools-encoded parameter within `node_type`.`auto_sync_config`
	$form['feeds_auto_sync']['fna_importer']  = array(
		'#type' => 'select',
		'#options' => $form_datas['importers']['valid'],
		'#title' => t('Which importer do you want the auto-sync to use?'),
		'#description' => t('Overridden settings include; deactivate missing items...'),
		'#default_value' =>	t($c->config->importer->value),
	);
	
	//	Secondary control. Destination: ctools-encoded parameter within `node_type`.`auto_sync_config`
	$form['feeds_auto_sync']['fna_cooldown']  = array(
		'#type' => 'select',
		'#options' => drupal_map_assoc(array(5,10,15,20,25,30,45,60)),
		'#title' => t('Cooldown delay on re-importing nodes.'),
		'#description' => t('This setting has two purposes, first to defeat recursion (which is triggered when an auto-update modifys a node, causing it to re-update), second to make the sync resistant to causing an importer lock if two users edit the same node at the same (ish) time.'),
		'#default_value' =>	$c->config->cooldown->value,
	);
	//	Secondary control. Destination: ctools-encoded parameter within `node_type`.`auto_sync_config`
	$form['feeds_auto_sync']['fna_block_field_edits']  = array(
		'#type' => 'checkboxes',
		'#options' => $form_datas['importer_mapped_fields'],
		'#title' => t('Block edits on these fields'),
		'#description' => t('Check the node members you wish to make un-editable with the node form.'),
		'#default_value' => array_keys(get_object_vars($c->config->block_field_edits->value)),
	);
	
	array_push($form['#submit'], 	'feeds_node_autosync_nodetypeform_data');
	array_push($form['#validate'], 	'feeds_node_autosync_save_node_type_form_validate');
}

/**
 * Implemented by "feeds_node_autosync_form_node_type_form_alter", by adding this function to that form's "#submit" array.
 *
 * The columns added to the schema and db recieve their data from the form with this function.
 *
 * @param form
 *   The form array, containing the "current" state of the form.
 * @param form_state
 *   A keyed array containing the current state of the form.
*/
function feeds_node_autosync_nodetypeform_data ( $form, &$form_state ) {
	//	The 'fna_active' field is slightly vestigal at this point, but it doesn't hurt much.
	$num_updated = db_update('node_type')
		->fields(array(
				'auto_sync_toggle' => $form_state['values']['fna_active']
		))
		->condition('type', $form['#node_type']->type)
		->execute();
	//	load the configuration object!
	$config = feeds_node_autosync_config($form['#node_type']->type);
	foreach($form_state['values'] as $form_field=>$form_value) {
		//	This changes the prefixed 'fna_' fields into their appropriate key within the configuration object.
		if(substr($form_field,0,4) == 'fna_') {		//	First - only use the proper prefix...
			$field = substr($form_field,4);		//	The name within the configuration object doesn't need the prefix.
			if(!is_null($form_value)) {		//	Setting values to NULL should delete them (or fail to set them)
				if(is_array($form_value)) {	//	Arrays need to be looped through, this is currently most important for the "uneditable fields" settings.
					$values = array();
					foreach($form_value as $key=>$value) {	//	Build it out!
						if($value != "0") {
							$values[$key] = $value;
						} else {
							//$values[$key] = FALSE;
						}
					}
					$config->config->{$field}->value = $values;	//	It's ready now for prime-time!
				} elseif(is_numeric($form_value)) {
					$config->config->{$field}->value = intval($form_value);	//	Integers are pretty easy. Store it as an int!
				} else
					$config->config->{$field}->value = $form_value;	//	Otherwise don't do anything special.
			}
		}
	}
	feeds_node_autosync_config($form['#node_type']->type, $config);	//	This saves the config to the database.
	return array($form, $form_state);	//	This provides the changes to the UI.
}

/**
 * Implemented by "feeds_node_autosync_form_node_type_form_alter", by adding this function to that form's "#validate" array.
 *
 * The columns added to the schema and db are validated pre-save with this function.
 *
 * @param form
 *   The form array, containing the "current" state of the form.
 * @param form_state
 *   A keyed array containing the current state of the form.
*/
function feeds_node_autosync_save_node_type_form_validate ( $form, &$form_state ) {
	//	Validate 'fna_active'
	if(!is_numeric($form_state['values']['fna_active']))
		$form_state['values']['fna_active'] = intval($form_state['values']['fna_active']);
	
	//	Validate 'fna_importer'
	$validation_data = feeds_node_autosync_validate_importer($form_state['values']['fna_importer'], $form['#node_type']->type);
	if(!in_array($form_state['values']['fna_importer'],array_keys($validation_data['valid']),TRUE)) {
		drupal_set_message('Importer failed validation.','warning',TRUE);
		//dpm($validation_data);
		//dpm($form_state['values']['fna_importer']);
		$form_state['values']['fna_importer'] = null;
	}
	
	//	Validate 'fna_cooldown'
	if(!is_numeric($form_state['values']['fna_cooldown']))
		$form_state['values']['fna_cooldown'] = intval($form_state['values']['fna_cooldown']);
	if($form_state['values']['fna_cooldown'] < 1)
		$form_state['values']['fna_cooldown'] = 1;
	if($form_state['values']['fna_cooldown'] > 60)
		$form_state['values']['fna_cooldown'] = 60;
	
	//	Validate 'fna_block_field_edits'
	//		There's a potential UI frustration here; if the user wants to block edits on a field not mapped in the importer they chose, this will disallow them to do so.
	//		The reason for this is that if the field isn't controlled by the import, blocking edits using the form will render this field useless for most purposes.
	//		I'm considering making this validation rule optional in the module configuration options (which don't exist yet)
	$valid_fields = array();
	foreach($form_state['values']['fna_block_field_edits'] as $field_name=>$field_value) {
		if(in_array($field_name,array_keys($validation_data['mapped_fields']))) {
			$valid_fields[$field_name] = $field_value;
		}
	}
	$form_state['values']['fna_block_field_edits'] = $valid_fields;
	unset($valid_fields);
}

/**
 * Implemented by the above _form_alter hook and "feeds_node_autosync_save_node_type_form_validate" by implicit call
 *
 * This function takes an importer name and validates its settings
 *
 * @param importer_id
 *   The string id of the importer
 * @param node_type
 *   The node id string
 */
function feeds_node_autosync_validate_importer($importer_id, $node_type) {
	//	$ret will be returned, these are the keys that should always be there.
	$ret = array('all' => array(), 'valid' => array(), 'mapped_fields' => array());
	//	Load the importer and the config thereof
	$importer = feeds_importer($importer_id);
	$importer_config = $importer->getConfig();
	unset($importer);	//	Since this is no longer needed, why not delete it?
	//	Check and enforce that the node type (bundle) matches the current, and that the feed is set to 'update existing nodes'.
	//	Also required is at least one field processed as a unique identifier.
	$ret['all'][$importer_config['name']] = array();
	$ret['all'][$importer_config['name']]['FEED_URL_mapped'] = false;
	$ret['all'][$importer_config['name']]['processor_includes_unique'] = false;
	$ret['all'][$importer_config['name']]['fields'] = array();
	$ret['all'][$importer_config['name']]['fail_messages'] = array();
	//	$form_datas['all_form_importers'][$importer_config['name']]['config'] = $importer_config['processor']['config'];
	$required_maps = array(
		'unique' => array(
			'map_required_key' => 'unique',
			'map_required_value' => 1,
			'storage_key' => 'processor_includes_unique',
			'fail_message' => t('You need to map at least one field as an unique marker per record, otherwise it can\'t differentiate between items.'),
		),
		'url' => array(
			'map_required_key' => 'target',
			'map_required_value' => 'url',
			'storage_key' => 'feed_url_mapped',
			'fail_message' => t('You need to map the URL for each item, otherwise the item can\'t be synced when edited.'),
		),
		'feed_source' => array(
			'map_required_key' => 'target',
			'map_required_value' => 'feeds_source',
			'storage_key' => 'feed_source_mapped',
			'fail_message' => t('You need to map the feed_source.'),
		),
		/*'not_found' => array(
			'map_required_key' => 'never_there',
			'map_required_value' => 'not_set',
			'storage_key' => 'failtest',
			'fail_message' => t('Fail test successful.'),
		),*/
	);
	if($importer_config['processor']['config']['bundle'] != $node_type) {
		$ret['all'][$importer_config['name']]['fail_messages'][] = t("Improper node type. ('!node_type_found' needs to be '!node_type_required')",array('!node_type_found'=>$importer_config['processor']['config']['bundle'],'!node_type_required'=>$node_type));
	}
	if($importer_config['processor']['config']['update_existing']."" != "2") {
		$ret['all'][$importer_config['name']]['fail_messages'][] = t("Processor not configured to 'Update existing nodes'. ('!update_existing' value not accepted.)",array('!update_existing'=>$importer_config['processor']['config']['update_existing']));
	}
	if($importer_config['processor']['config']['update_non_existent']."" != "skip") {
		$ret['all'][$importer_config['name']]['fail_messages'][] = t("Processor not configured to 'skip non-existent nodes'. ('!update_non_existent' value not accepted.)",array('!update_non_existent'=>$importer_config['processor']['config']['update_non_existent']));
	}
	if($importer_config['processor']['config']['skip_hash_check']."" != "1") {
		$ret['all'][$importer_config['name']]['fail_messages'][] = t("Processor not configured to 'skip hash check'. ('!skip_hash_check' value not accepted.)",array('!skip_hash_check'=>$importer_config['processor']['config']['skip_hash_check']));
	}
	if(count($ret['all'][$importer_config['name']]['fail_messages']) == 0) {
		//	Here is built the array of fields for locking
		//	Also checked here is the existence of a "FEED_URL" on an item level. If the items don't have a "FEED_URL" there is no capacity to auto-sync its data.
		foreach($importer_config['processor']['config']['mappings'] as $map) {
			$importer_field = field_info_instance('node',$map['target'],$node_type);
			if($importer_field) {	//	This verifies that the mapped field is a field in the content type
				$ret['all'][$importer_config['name']]['fields'][$importer_field['field_name']] = t($importer_field['label']);
				$ret['mapped_fields'][$importer_field['field_name']] = t($importer_field['label']);
			}
			foreach($required_maps as $required_fieldname => $requirement_parameters) {
				if(array_key_exists($requirement_parameters['map_required_key'], $map) && $map[$requirement_parameters['map_required_key']] == $requirement_parameters['map_required_value']) {
					$ret['all'][$importer_config['name']][$requirement_parameters['storage_key']] = true;
				}
			}
			unset($importer_field);	//	Since this is no longer needed, why not delete it?
		}
		$passed_requirements = true;
		$fail_messages = "";
		//	Check each required map and attach the fail message if it fails validation.
		foreach($required_maps as $required_fieldname => $requirement_parameters) {
			if(!array_key_exists($requirement_parameters['storage_key'], $ret['all'][$importer_config['name']])) {
				$passed_requirements = false;
				$fail_messages .= "<div>".$requirement_parameters['fail_message']."</div>";
			}
		}
		//	If this importer had a mapped "FEED_URL" and passed all validation, then add it to the list of form_importers!
		if($passed_requirements) {
			$ret['valid'][$importer_config['name']] = format_string("!importer_description [!importer_name]", array('!importer_description'=>$importer_config['description'],'!importer_name'=>$importer_config['name']));
		} else {
			$ret['all'][$importer_config['name']]['fail_messages'][] = $fail_messages;
		}
		unset($fail_messages);
	}
	unset($required_maps);	//	Since this is no longer needed, why not delete it?
	unset($importer_config);	//	Since this is no longer needed, why not delete it?
	return $ret;
}

/**
 * Implemented whenever the configuration for a given node type needs to be accessed (recalled or stored)
 *
 * The first argument is always the node_type, the second is optional and will store the given data as the config.
 *
 * @param node_type
 *   The string id of the node type
 * @param config_obj
 *   The settings to store, changes the return type to int of number of rows updated (should be 0 or 1)
 */
function feeds_node_autosync_config( $node_type, $config_obj = NULL ) {
	//	This section is for storing the settings data ($config_obj provided)
	if(!is_null($config_obj)) {
		if(is_string($config_obj)) {	//	If it is a string, we need to get it into the correct "shape" by encoding it into an object, then turning it back into a string.
			$config_str = $config_obj;
			$config_obj = json_decode($config_str);
			$config_str = json_encode($config_obj);
		} else {	//	If it isn't a string, then it get simpler - simply change it into a string.
			$config_str = json_encode($config_obj);
		}
		$num_updated = db_update('node_type')
			->fields(array(
					'auto_sync_config' => $config_str
			))
			->condition('type', $node_type)
			->execute();
		if($num_updated > 0)
			return $num_updated;
		else
			return FALSE;
	} else {	//	The above always ends with a 'return' so this section doesn't strictly need to be in an 'else', but for legibility I've left it in one.
		//	recall the existing settings from the database.
		$result = db_select('node_type', 'nt')
			->fields('nt', array('auto_sync_config'))
			->condition('nt.type',$node_type)
			->range(0,1)
			->execute();
		$config_db = $result->fetchAssoc();
		//	if there isn't one - get the default and set that, also load it into the '$result' container.
		if($result->rowCount() == 0 || $config_db == array('auto_sync_config'=>NULL) || $config_db == NULL) {
			module_load_install('feeds_node_autosync');		//	the install script contains the schema. First we load it.
			$config = feeds_node_autosync_schema();		//	Then we get the default schema.
			$config = $config['feeds_node_autosync_config'];	//	 We don't need that root element...
			$config['config'] = $config['default_config'];	//	Then we "copy" the default into place.
			$config_str = json_encode($config);		//	We need the string version to store in the database.
			$num_updated = db_update('node_type')
				->fields(array(
						'auto_sync_config' => $config_str
				))
				->condition('type', $node_type)
				->execute();		//	Put it in the database!
			$result = db_select('node_type', 'nt')
				->fields('nt', array('auto_sync_config'))
				->condition('nt.type',$node_type)
				->range(0,1)
				->execute();
			$config_db = $result->fetchAssoc();		//	Retrieve it from the database (to ensure that what the function returns is literally what the database contains).
		}
		//	Failure checking.		
		if($result->rowCount() > 0) {
			//	Get the database string
			$config_str = $config_db['auto_sync_config'];
			//	Turn it into the object...
			$config_obj = json_decode($config_str);
			//	Return the result!
			return $config_obj;
		} else {
			//	In case of error, let the user know it failed.
			drupal_set_message("Failure to store the default configuration for node type '".$node_type."' in the database. Configuration not set. Proceed with caution.", 'error', TRUE);
			return $config;
		}
	}
}

/**
 *  Implements hook_feeds_before_import().
 *
 * @param FeedsSource $source
 *   The FeedsSource object of the hooked feed_source...
 */
function feeds_node_autosync_feeds_before_import( FeedsSource $source ) {
	//$c = feeds_node_autosync_config($form['#node_type']->type);	//	No longer required
	watchdog('feeds_node_autosync',t("Autosync feed triggered for @feed_source_name pageload:@page_load",array('@feed_source_name'=>$source->importer->getConfig()['name'],'@page_load'=>REQUEST_TIME)),NULL,WATCHDOG_DEBUG);
	//	Load the config (perhaps we should standardize the variable name loaded for this?)
	$fna = feeds_node_autosync_config($source->importer->getConfig()['content_type']);
	$configured_autosync_import = ($source->importer->getConfig()['name'] == $fna->config->importer->value);	//	Boolean on the logic that determines is autosync should be suspended or not...
	if(!$configured_autosync_import) {
		//	Alert the user that autosync has been temporarily suspended due to "large batch" import.
		drupal_set_message(t("%active_importer importing to %node_type which is configured to auto-feed from %configured_importer. Temporarily suspending auto-sync for this content type until this import completes.",array('%active_importer'=>$source->importer->getConfig()['name'],'%node_type'=>$source->importer->getConfig()['content_type'],'%configured_importer'=>$fna->config->importer->value)));
		$fna->config->active_preimport = clone $fna->config->active;	//	Save this to reset the values after the import completes.
		$fna->config->active->value = -1;	//	-1 is a semi-reserved value for 'active' which indicates the temporary suspension
		feeds_node_autosync_config($source->importer->getConfig()['content_type'],$fna);	//	Save the temporary suspension.
	}
}

/**
 *  Implements hook_feeds_after_import().
 *
 * @param FeedsSource $source
 *   The FeedsSource object of the hooked feed_source...
 */
function feeds_node_autosync_feeds_after_import( FeedsSource $source ) {
	//	Load the config (perhaps we should standardize the variable name loaded for this?)
	$fna = feeds_node_autosync_config($source->importer->getConfig()['content_type']);
	$configured_autosync_import = ($source->importer->getConfig()['name'] == $fna->config->importer->value);	//	Boolean on the logic that determines is autosync should be suspended or not...
	if(!$configured_autosync_import && $fna->config->active->value == -1) {
		drupal_set_message(t("%active_importer import complete. Resetting 'active' parameter on %configured_importer to %active.",array('%active_importer'=>$source->importer->getConfig()['name'],'%configured_importer'=>$fna->config->importer->value,'%active'=>$fna->config->active_preimport->value)));
		$fna->config->active->value = $fna->config->active_preimport->value;
		unset($fna->config->active_preimport);
		feeds_node_autosync_config($source->importer->getConfig()['content_type'],$fna);
	}
	watchdog('feeds_node_autosync',t("Autosync feed completed for @feed_source_name pageload:@page_load",array('@feed_source_name'=>$source->importer->getConfig()['name'],'@page_load'=>REQUEST_TIME)),NULL,WATCHDOG_DEBUG);
}

/**
 *  Implements hook_feeds_before_update().
 *
 * @param FeedsSource $source
 *   The FeedsSource object of the hooked feed_source...
 * @param item
 *   The the feed item being updated
 * @param entity_id
 *   The node id string being updated
 */
function feeds_node_autosync_feeds_before_update( FeedsSource $source, $item, $entity_id ) {
	$entity = array_pop(entity_load('node',array($entity_id)));	//	Load the entity. Returns an array, we need the first one (probably only one)
	//	Retrieve the updated date from the database to detect cooldown collision.
	$feeds_items_result = db_select('feeds_item', 'n')
		->fields('n', array('id', 'url', 'entity_id', 'imported'))
		->condition('entity_id', $entity_id)
		->condition('entity_type', 'node')
		->execute()
		->fetchAssoc();
	$fna = feeds_node_autosync_config($source->importer->getConfig()['content_type']);
	if($fna->config->active->value == 1) {
		if( (REQUEST_TIME - $feeds_items_row['imported']) < ($fna->config->cooldown->value) ) {
			//	If the last update happened within the cooldown interval, this update event should be skipped and indicates positively that the node is both updated and appropriately autosyncing.
			drupal_set_message(t('%node_title updated from feed source.',array('%node_title'=>$entity->title)),'status',TRUE);
			$entity->skip = TRUE;
		} else {
			$entity->skip = FALSE;
		}
	}
}

/**
 *  Implements hook_feeds_before_update().
 *
 * @param FeedsSource $source
 *   The FeedsSource object of the hooked feed_source...
 * @param item
 *   The the feed item being updated
 * @param entity_id
 *   The node id string being updated
 */
function feeds_node_autosync_feeds_presave(FeedsSource $source, $entity, $item) {
	//	If the entity is marked for skip - update the feeds_item to do so.
	if($entity->skip) {
		$entity->feeds_item->skip = TRUE;
	}
}

