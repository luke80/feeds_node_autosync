<?php

/**
 * Implements hook_help().
 *
 * Displays help and module information.
 *
 * @param path
 *   Which path of the site we're using to display help
 * @param arg
 *   Array that holds the current path as returned from arg() function
*/
function feeds_node_autosync_help($path, $arg) {
	switch ($path) {
		case "admin/help#feeds_node_autosync":
			return '<p>' . t("Connect nodes to their defined feed URL for automatic updates!") . '</p>';
			break;
	}
}

/**
 * Implements hook_schema_alter().
 *
 * Modifies the 'node_type' schema, adding a toggle and config column
 *
 * @param schema
 *   Entire schema, used to modify data the structure
*/
function feeds_node_autosync_schema_alter(&$schema) {
	$schema['node_type']['fields']['auto_sync_toggle'] = array(
			'type' => 'int',
			'not null' => TRUE,
			'default' => 0,
			'description' => 'Toggle setting for auto-sync (feeds) module.',
	);
	$schema['node_type']['fields']['auto_sync_config'] = array(
		'type' => 'blob',
		'size' => 'big',
		'not null' => FALSE,
		'serialize' => TRUE,
		'description' => 'Configuration for auto-sync (feeds) module.',
	);
}

/**
 * Implements hook_enable().
 *
 * !Mostly for development purposes... remove for release
 * Ensures that installation script is re-run with disable, re-enable 
 *
 */
function feeds_node_autosync_enable() {
	feeds_node_autosync_install();
}

/**
 * Implements hook_node_update().
 *
 * Main engine of the autosync. Adds the automatic import request to node update events via the hook.
 *
 * @param node
 *   Contains the node which was updates (the update that fired the hook)
*/
function feeds_node_autosync_node_update( $node ) {
	$c = feeds_node_autosync_config($node->type);
	$feeds_items_result = db_select('feeds_item', 'n')
		->fields('n', array('id', 'url', 'entity_id', 'imported'))
		->condition('entity_id', $node->nid) //Published.
		->condition('entity_type', 'node')
		->execute();
	$feeds_items_row = $feeds_items_result->fetchAssoc();
	
	if( $feeds_items_row['imported'] < (REQUEST_TIME - $c->config->cooldown->value) ) {
		//$feed_source = feeds_source($feeds_items_row['id']);	//	This is the source that originally created the node. This is now overridden by the setting on the node type form.
		$feed_source = feeds_source($c->config->importer->value);
		
		$feed_config = $feed_source->getConfig();
		$feed_config['FeedsHTTPFetcher']['source'] = $feeds_items_row['url'];
		$feed_config['FeedsNodeProcessor']['update_non_existent'] = 'skip';
		$feed_config['FeedsNodeProcessor']['skip_hash_check'] = 1;
		
		$feed_source->setConfig($feed_config);
		$feed_source->save();
		dpm($feed_config);
		$feed_source->startImport();
	} else {
		dpm("Not updating due to cooldown limit. ".$feeds_items_row['imported']." < ".(REQUEST_TIME - $c->config->cooldown->value));
	}
}

/**
 * Implements hook_FORM_ID_form_alter().
 *
 * Modifies the "node_type" form. Adds configuration options to the node type for auto-sync of content of this type.
 *
 * @param form
 *   The form array, containing the "current" state of the form.
 * @param form_state
 *   A keyed array containing the current state of the form.
 * @param form_id
 *   String representing the name of the form itself. This is the "FORM_ID" part of the name of the function.
*/
function feeds_node_autosync_form_node_type_form_alter( &$form, &$form_state, $form_id ) {
	//	Retrieve the configuration object..
	$c = feeds_node_autosync_config($form['#node_type']->type);
	
	//	Initialize the $form_datas to contain all the requisite data places
	$form_datas = array(
			'config_problems'		=> array(),		//	This array is populated with helpful text to assist the user to configure the feed to work with this module.
			'importers' => array(
				'all'	=> array(),	//	This array is populated with all the form importers found, and holds a boolean value which is true if this importer is valid for auto-syncing the nodes.	
				'valid'		=> array(),	//	This array is populated with the form importers that are valid for use.
				'fields'	=> array(),	//	This array is populated with the form fields that are mapped specifically in this importer.
			),
			'importer_mapped_fields'	=> array(),	//	This array is populated with the mapped fields that are configured, and might need to be disabled to prevent modification to fields intended to be driven only by the feed.
	);
	if($form['#node_type']->module != "node") {
		$form_datas['config_problems'][] = "Sorry, the type needs to be 'node', not ".$form['#node_type']->module;
	} else {
		//	The importer needs to be configured for the node type loaded...
		foreach(feeds_importer_load_all() as $importer) {
			$validation_data = feeds_node_autosync_validate_importer($importer->id, $form['#node_type']->type);
			$form_datas['importers']['all'] =		array_merge($form_datas['importers']['all'], $validation_data['all']);
			$form_datas['importers']['valid'] =		array_merge($form_datas['importers']['valid'], $validation_data['valid']);
			$form_datas['importers']['fields'] =	array_merge($form_datas['importers']['fields'], $validation_data['mapped_fields']);
			$form_datas['importer_mapped_fields'] =	array_merge($form_datas['importer_mapped_fields'], $validation_data['mapped_fields']);
		}
	}
	if(count($form_datas['importers']['all']) == 0) {	//	First problem to identify. No importers!
		$form_datas['config_problems'][] =	'<p class="error">You don\'t even have an importer set up yet! Sorry, but you\'ll have to set one up with this content type <em>'.$form['#node_type']->type.'</em> first.</p>';
	} else if(count($form_datas['importers']['valid']) == 0) {	//	Second problem to identify. No valid importers!
		$form_datas['config_problems'][] =	'<p class="error">Your configured feed needs to have a <em>feed_source</em> set. You do this by setting one of the import fields mapped to <em>feed_source</em>. It also helps to make the data provided function as a sync source for the specific node it creates/updates.</p>';
	} else if(count($form_datas['importer_mapped_fields']) == 0) {	//	Third problem to identify. No fields mapped to update in this content type.
		$form_datas['config_problems'][] =	'<p class="error">It appears that your <em>processor</em> is either missing or is not set up to connect to this content type with any imported columns. Additionally, you are also required to have at least one unique identifier mapped to this content type ('.$form['#node_type']->type.'), and the processor set to <em>update existing nodes</em>.';
	}
	
	//	Verify successful import of nodes with 'feeds_source' set in db.
	$missing_nodes_error = 'Before setting auto-update on a content type, you need to successfully sync your nodes manually at least once. (No \'feed_source\' data found.)';
	foreach($form_datas['importers']['valid'] as $importer_name=>$importer) {
		$missing_nodes_error .= '<p class="error"><a href="/import/'.$importer_name.'">Click here to go import page for "'.$importer.'"</a>';
	}
	$form_datas['nids'] = db_select('node', 'n')
		->fields('n', array('nid'))
		->fields('n', array('type'))
		->condition('n.type', $form['#node_type']->type)
		->condition('n.status', 1)
		->execute()
		->fetchCol(); // returns an indexed array
	if(count($form_datas['nids']) > 0 && count($form_datas['config_problems']) == 0) {
		$result = db_select('feeds_source', 'fs')
			->fields('fs', array('id'))
			->fields('fs',array('source'))
			->condition('fs.feed_nid', $form_datas['nids'])
			->condition('fs.source', '', $operator = '<>')
			->range(0,1)
			->execute();
		if($result->rowCount() == 0) {
			$form_datas['config_problems'][] =	$missing_nodes_error;
		}
	} else if(count($form_datas['config_problems']) == 0) {
		$form_datas['config_problems'][] =	$missing_nodes_error;
	}
	unset($form_datas['nids']);
	unset($result);
	unset($missing_nodes_error);
	
	/*
		*	Finally! Begin modifications to the form
	*/
	//	Create the new tab (appears at the bottom of the form, probably under "Comment settings"
	$form['feeds_auto_sync'] = array(
	 '#type' => 'fieldset',
	 '#title' => t('Feeds Auto-Sync'),
	 '#collapsible' => TRUE,
	 '#collapsed' => TRUE,
	 '#group' => 'additional_settings',
	);
	//	If there are errors to display, display them.
	if(count($form_datas['config_problems']) != 0) {
		$form['feeds_auto_sync']['fna_errors']  = array(
				'#markup' => t(implode("<br/>",$form_datas['config_problems'])),
		);
		//	Since the form settings don't matter if they can't work, hide them.
		return true;
	}
	//	Main control setting. Destination: `node_type`.`auto_sync_toggle`
	$form['feeds_auto_sync']['fna_active']  = array(
		'#type' => 'checkbox',
		'#title' => t('Auto-sync this content type?'),
		'#description' => t('With this checked, when items of this type are modified they will trigger a re-import from the configured source.'),
	);
	if($c->config->active->value == 1) {
		$form['feeds_auto_sync']['fna_active']['#attributes'] = array('checked'=>'checked');
	}
	//	Secondary control. Destination: ctools-encoded parameter within `node_type`.`auto_sync_config`
	$form['feeds_auto_sync']['fna_importer']  = array(
		'#type' => 'select',
		'#options' => $form_datas['importers']['valid'],
		'#title' => t('Which importer do you want the auto-sync to use?'),
		'#description' => t('Overridden settings include; deactivate missing items...'),
		'#default_value' =>	t($c->config->importer->value),
	);
	
	//	Secondary control. Destination: ctools-encoded parameter within `node_type`.`auto_sync_config`
	$form['feeds_auto_sync']['fna_cooldown']  = array(
		'#type' => 'select',
		'#options' => drupal_map_assoc(array(5,10,15,20,25,30,45,60)),
		'#title' => t('Cooldown delay on re-importing nodes.'),
		'#description' => t('This setting has two purposes, first to defeat recursion (which is triggered when an auto-update modifys a node, causing it to re-update), second to make the sync resistant to causing an importer lock if two users edit the same node at the same (ish) time.'),
		'#default_value' =>	$c->config->cooldown->value,
	);
	//	Secondary control. Destination: ctools-encoded parameter within `node_type`.`auto_sync_config`
	$form['feeds_auto_sync']['fna_block_field_edits']  = array(
		'#type' => 'checkboxes',
		'#options' => $form_datas['importer_mapped_fields'],
		'#title' => t('Block edits on these fields'),
		'#description' => t('Check the node members you wish to make un-editable with the node form.'),
		'#default_value' => array_keys(get_object_vars($c->config->block_field_edits->value)),
	);
	/*
		* Todo:
		* connect these settings to sync code
		* create importer overrides and complete the description on the "importer select" form UI
	*/
	
	array_push($form['#submit'], 	'feeds_node_autosync_nodetypeform_data');
	array_push($form['#validate'], 	'feeds_node_autosync_save_node_type_form_validate');
}

/**
 * Implemented by "feeds_node_autosync_form_node_type_form_alter", by adding this function to that form's "#submit" array.
 *
 * The columns added to the schema and db recieve their data from the form with this function.
 *
 * @param form
 *   The form array, containing the "current" state of the form.
 * @param form_state
 *   A keyed array containing the current state of the form.
*/
function feeds_node_autosync_nodetypeform_data ( $form, &$form_state ) {
	$num_updated = db_update('node_type')
		->fields(array(
				'auto_sync_toggle' => $form_state['values']['fna_active']
		))
		->condition('type', $form['#node_type']->type)
		->execute();
	
	$config = feeds_node_autosync_config($form['#node_type']->type);
	foreach($form_state['values'] as $form_field=>$form_value) {
		if(substr($form_field,0,4) == 'fna_') {
			$field = substr($form_field,4);
			if(!is_null($form_value)) {
				if(is_array($form_value)) {
					$values = array();
					foreach($form_value as $key=>$value) {
						if($value != "0") {
							$values[$key] = $value;
						} else {
							//$values[$key] = FALSE;
						}
					}
					$config->config->{$field}->value = $values;
				} elseif(is_numeric($form_value)) {
					$config->config->{$field}->value = intval($form_value);
				} else
					$config->config->{$field}->value = $form_value;
			}
		}
	}
	feeds_node_autosync_config($form['#node_type']->type, $config);
	return array($form, $form_state);
}

/**
 * Implemented by "feeds_node_autosync_form_node_type_form_alter", by adding this function to that form's "#validate" array.
 *
 * The columns added to the schema and db are validated pre-save with this function.
 *
 * @param form
 *   The form array, containing the "current" state of the form.
 * @param form_state
 *   A keyed array containing the current state of the form.
*/
function feeds_node_autosync_save_node_type_form_validate ( $form, &$form_state ) {
	//	Validate 'fna_active'
	if(!is_numeric($form_state['values']['fna_active']))
		$form_state['values']['fna_active'] = intval($form_state['values']['fna_active']);
	
	//	Validate 'fna_importer'
	$validation_data = feeds_node_autosync_validate_importer($form_state['values']['fna_importer'], $form['#node_type']->type);
	if(!in_array($form_state['values']['fna_importer'],array_keys($validation_data['valid']),TRUE)) {
		drupal_set_message('Importer failed validation.','warning',TRUE);
		//dpm($validation_data);
		//dpm($form_state['values']['fna_importer']);
		$form_state['values']['fna_importer'] = null;
	}
	
	//	Validate 'fna_cooldown'
	if(!is_numeric($form_state['values']['fna_cooldown']))
		$form_state['values']['fna_cooldown'] = intval($form_state['values']['fna_cooldown']);
	if($form_state['values']['fna_cooldown'] < 1)
		$form_state['values']['fna_cooldown'] = 1;
	if($form_state['values']['fna_cooldown'] > 60)
		$form_state['values']['fna_cooldown'] = 60;
	
	//	Validate 'fna_block_field_edits'
	//		There's a potential UI frustration here; if the user wants to block edits on a field not mapped in the importer they chose, this will disallow them to do so.
	//		The reason for this is that if the field isn't controlled by the import, blocking edits using the form will render this field useless for most purposes.
	//		I'm considering making this validation rule optional in the module configuration options (which don't exist yet)
	$valid_fields = array();
	foreach($form_state['values']['fna_block_field_edits'] as $field_name=>$field_value) {
		if(in_array($field_name,array_keys($validation_data['mapped_fields']))) {
			$valid_fields[$field_name] = $field_value;
		}
	}
	$form_state['values']['fna_block_field_edits'] = $valid_fields;
	unset($valid_fields);
}

/**
 * Implemented by the above _form_alter hook and "feeds_node_autosync_save_node_type_form_validate" by implicit call
 *
 * This function takes an importer name and validates its settings
 *
 * @param importer_id
 *   The string id of the importer
 * @param node_type
 *   The node id string
 */
function feeds_node_autosync_validate_importer($importer_id, $node_type) {
	$ret = array('all' => array(), 'valid' => array(), 'mapped_fields' => array());
	$importer = feeds_importer($importer_id);
	$importer_config = $importer->getConfig();
	unset($importer);	//	Since this is no longer needed, why not delete it?
	//	Check and enforce that the node type (bundle) matches the current, and that the feed is set to 'update existing nodes'.
	//	Also required is at least one field processed as a unique identifier.
	$ret['all'][$importer_config['name']] = array();
	$ret['all'][$importer_config['name']]['feeds_source_mapped'] = false;
	$ret['all'][$importer_config['name']]['processor_includes_unique'] = false;
	$ret['all'][$importer_config['name']]['fields'] = array();
	//	$form_datas['all_form_importers'][$importer_config['name']]['config'] = $importer_config['processor']['config'];
	if($importer_config['processor']['config']['bundle'] == $node_type && $importer_config['processor']['config']['update_existing']."" == "2") {
		//	Here is built the array of fields for locking
		//	Also checked here is the existence of a "feeds_source" on an item level. If the items don't have a "feeds_source" there is no capacity to auto-sync its data.
		foreach($importer_config['processor']['config']['mappings'] as $map) {
			$importer_field = field_info_instance('node',$map['target'],$node_type);
			if($importer_field) {	//	This verifies that the mapped field is a field in the content type
				$ret['all'][$importer_config['name']]['fields'][$importer_field['field_name']] = t($importer_field['label']);
				$ret['mapped_fields'][$importer_field['field_name']] = t($importer_field['label']);
				if(array_key_exists('unique', $map) && $map['unique']) {	//	This is inside the $importer_field to ensure that the field mapped as unique is inside this content type.
					$ret['all'][$importer_config['name']]['processor_includes_unique'] = true;
				}
			}
			if($map['target'] == "feeds_source") {	//	If a mapped item is the feeds_source, then this processor map can be used to auto-sync
				$ret['all'][$importer_config['name']]['feeds_source_mapped'] = true;
			}
			unset($importer_field);	//	Since this is no longer needed, why not delete it?
		}
		//	If this importer had a mapped "feeds_source" and at least one unique field, then add it to the list of form_importers!
		if($ret['all'][$importer_config['name']]['feeds_source_mapped'] && $ret['all'][$importer_config['name']]['processor_includes_unique']) {
			$ret['valid'][$importer_config['name']] = t($importer_config['description']);
		}
	}
	unset($importer_config);	//	Since this is no longer needed, why not delete it?
	return $ret;
}

/**
 * Implemented whenever the configuration for a given node type needs to be accessed (recalled or stored)
 *
 * The first argument is always the node_type, the second is optional and will store the given data as the config.
 *
 * @param node_type
 *   The string id of the node type
 * @param config_obj
 *   The settings to store, changes the return type to int of number of rows updated (should be 0 or 1)
 */
function feeds_node_autosync_config( $node_type, $config_obj = NULL ) {
	//	This section is for storing the settings data ($config_obj provided)
	if(!is_null($config_obj)) {
		if(is_string($config_obj)) {	//	If it is a string, we need to get it into the correct "shape" by encoding it into an object, then turning it back into a string.
			$config_str = $config_obj;
			$config_obj = json_decode($config_str);
			$config_str = json_encode($config_obj);
		} else {	//	If it isn't a string, then it get simpler - simply change it into a string.
			$config_str = json_encode($config_obj);
		}
		$num_updated = db_update('node_type')
			->fields(array(
					'auto_sync_config' => $config_str
			))
			->condition('type', $node_type)
			->execute();
		if($num_updated > 0)
			return $num_updated;
		else
			return FALSE;
	} else {	//	The above always ends with a 'return' so this section doesn't strictly need to be in an 'else', but for legibility I've left it in one.
		//	recall the existing settings from the database.
		$result = db_select('node_type', 'nt')
			->fields('nt', array('auto_sync_config'))
			->condition('nt.type',$node_type)
			->range(0,1)
			->execute();
		$config_db = $result->fetchAssoc();
		//	if there isn't one - get the default and set that, also load it into the '$result' container.
		if($result->rowCount() == 0 || $config_db == array('auto_sync_config'=>NULL) || $config_db == NULL) {
			module_load_install('feeds_node_autosync');		//	the install script contains the schema. First we load it.
			$config = feeds_node_autosync_schema();		//	Then we get the default schema.
			$config = $config['feeds_node_autosync_config'];	//	 We don't need that root element...
			$config['config'] = $config['default_config'];	//	Then we "copy" the default into place.
			$config_str = json_encode($config);		//	We need the string version to store in the database.
			$num_updated = db_update('node_type')
				->fields(array(
						'auto_sync_config' => $config_str
				))
				->condition('type', $node_type)
				->execute();		//	Put it in the database!
			$result = db_select('node_type', 'nt')
				->fields('nt', array('auto_sync_config'))
				->condition('nt.type',$node_type)
				->range(0,1)
				->execute();
			$config_db = $result->fetchAssoc();		//	Retrieve it from the database (to ensure that what the function returns is literally what the database contains).
		}
		//	Failure checking.		
		if($result->rowCount() > 0) {
			//	Get the database string
			$config_str = $config_db['auto_sync_config'];
			//	Turn it into the object...
			$config_obj = json_decode($config_str);
			//	Return the result!
			return $config_obj;
		} else {
			//	In case of error, let the user know it failed.
			drupal_set_message("Failure to store the default configuration for node type '".$node_type."' in the database. Configuration not set. Proceed with caution.", 'error', TRUE);
			return $config;
		}
	}
}